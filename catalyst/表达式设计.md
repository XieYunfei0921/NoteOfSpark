#### 关系代数相关概念

由关系代数运算经有限次复合而成的式子称为关系代数表达式。这种表达式的运算结果仍然是一个关系。

1. 并

   使用类似`UNION`表达式的操作逻辑

2. 交

   使用类似于`INTERSECT`的操作逻辑

3. 差

   使用类似于`EXCEPT`的操作逻辑

4. 乘

5. 选择

   使用逻辑表达式进行分支选择

6. 投影

   基本投影: 在选择字段列表中出现的某个字段,前后链表之间形成投影

   广义投影: 投影表达式是个表达式

7. 联接

   外连接,内连接

8. 除

9. 自然连接

   使用类似`NATURAL JOIN`操作逻辑

#### 关于表达式的设计

设计一个高灵活度可用的表达式需要考虑到如下几个问题:

**必要功能**

1. 避免硬编码,提供有状态的查询

   ```scala
   trait Nondeterministic extends Expression {
     final override lazy val deterministic: Boolean = false
     final override def foldable: Boolean = false
   
     @transient
     private[this] var initialized = false
   
     /**
      * Initializes internal states given the current partition index and mark this as initialized.
      * Subclasses should override [[initializeInternal()]].
      */
     final def initialize(partitionIndex: Int): Unit = {
       initializeInternal(partitionIndex)
       initialized = true
     }
   
     protected def initializeInternal(partitionIndex: Int): Unit
   
     /**
      * @inheritdoc
      * Throws an exception if [[initialize()]] is not called yet.
      * Subclasses should override [[evalInternal()]].
      */
     final override def eval(input: InternalRow = null): Any = {
       require(initialized,
         s"Nondeterministic expression ${this.getClass.getName} should be initialized before eval.")
       evalInternal(input)
     }
   
     protected def evalInternal(input: InternalRow): Any
   }
   ```

2. 表达式不应当有代码生成器的实现,且工作在解释模式下

3. 不允许空值进行计算

4. 允许表达式为子查询类型

**可选功能**

1. 提供`UDF/UDAF/UDTF`的非`sql`功能实现

   ```scala
   trait NonSQLExpression extends Expression {
     final override def sql: String = {
       transform {
         case a: Attribute => new PrettyAttribute(a)
         case a: Alias => PrettyAttribute(a.sql, a.dataType)
       }.toString
     }
   }
   ```

2. 提供高级函数功能,例如排序,求和,均值等等

3. 提供N元表达式的功能(简化运算和类型判断)

4. 对于输入参数做隐式转换

5. 针对于复杂类型做合并(例如`case when`)

6. 不可预估类型查询

   ```scala
   trait Unevaluable extends Expression {
   
     final override def eval(input: InternalRow = null): Any =
       throw new UnsupportedOperationException(s"Cannot evaluate expression: $this")
   
     final override protected def doGenCode(ctx: CodegenContext, ev: ExprCode): ExprCode =
       throw new UnsupportedOperationException(s"Cannot generate code for expression: $this")
   }
   ```

   

7. 运行时替换

#### 确定查询和不确定查询

满足以下任意条件的都是不确定查询:

1. 依赖于可变的内部状态
2. 依赖于不属于子表达式列表的隐式输入
3. 存在有不确定的子查询节点
4. 通过子操作符假定了输入满足特定条件



#### 表达式的可折叠性

在查询执行之前,表达式是一个静态的常量. 下面列举常用的折叠情况.

1. `Coalesce`在所有子节点可折叠的时候是可折叠的
2. 当二元表达式`BinaryExpression`左右节点都是可折叠的时候,这个表达式就是可折叠的
3. `Not`,`Not Null`,`Is Not Null`在子节点是折叠的情况下就是可折叠的
4. `Literal`常量是可折叠的
5. `Cast`,`UnaryMinus`在子节点是折叠的情况下是可折叠的



#### 表达式的计算和初始化

表达式的执行包含初始化和计算两个部分.